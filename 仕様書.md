# FlowPython 要件定義（ドラフト/MVP現況反映）

最終更新: 2025-08-29

本書は、Web ブラウザ上で「ブロック（ノード）を線でつないで Python を実行」でき、Jupyter Kernel を裏で利用して出力をリアルタイムに反映するシステムの要件定義ドラフトです。現況（MVP実装）に合わせて更新しています。

---

## 1. 目的・ゴール

- ノーコード/ローコードに近い体験で、Python によるデータ処理・可視化・アルゴリズム試作を「ブロック線図」で構築・実行できる。
- Jupyter Kernel をバックグラウンドで用い、対話的実行と途中結果の保持を行い、出力をブラウザにリアルタイム反映する。
- 再現性（環境・依存関係・パラメータ・実行順序）を担保し、プロジェクトとして保存/共有可能にする。
- ローカル運用を基本とし、オフラインでも主要機能が動作する「ローカルファースト」を目指す。

成功基準（初期）：
- サンプルフロー（CSV 読込→前処理→集計→可視化）をブラウザ上で作成・保存・再実行できる。
- 実行途中の各ノードの出力プレビューを UI で逐次（ストリーミング）確認できる。
- バックグラウンドの Jupyter Kernel 実行により、コード送信→出力（表・図・ログ）がリアルタイムに UI に反映される。

現況サマリ（2025-08-29時点）：
- フロントは静的HTML/ESM JS。Pandas/NumPy/Sklearn/純Pythonのノードパッケージを読み込み、ノードをキャンバスに追加・接続可能。
- 右ペインでログとプレビュー（DataFrame HEAD/Describe、画像）を表示。プレビュー表示モード切替（All/Plots/None）。
- 実行は生成コードを `/run` にPOST、出力は `/ws` のIOPubで受信。差分ハッシュでノードごとにSKIP最適化。
- 変数パネル（`/api/variables`）でカーネルのグローバル変数を一覧・DataFrameプレビュー・CSVダウンロード（`/api/variables/{name}/export`）。
- フロー永続化API（`/api/flows`）とサーバアップロードAPI（`/api/uploads`）を提供。保存先は `PYFLOWS_DATA_DIR` または `/data/flows`。
- 認証は任意（`PYFLOWS_API_TOKEN`）。HTTPはBearer、WSは`?token=` で付与。

## 2. 想定ユーザー/ユースケース

- データサイエンティスト/エンジニア：前処理〜可視化〜軽いモデリングの試作。
- 制御/信号処理/数値解析：ブロック接続で処理パイプラインの可視化と検証。
- 教育用途：Python・データ処理の学習（可視化と段階的理解）。

主要ユースケース：
1) ファイル/DB からのデータ読込→前処理→特徴量作成→プロット→レポート化
2) 関数群のノード化→パラメータ実験→比較プロット
3) 外部 API からの取得→変換→ダッシュボード表示（簡易ストリーミング）

## 3. 用語（簡易）

- ノード（ブロック）：処理単位。入力ポート/出力ポートを持ち、Python コードで実装。
- エッジ（ワイヤ）：ノード間のデータフロー接続。
- フロー（グラフ）：ノードとエッジの集合。
- カーネル：Jupyter の Python 実行コンテキスト。
- シート（Sheet）：プロジェクト内の独立キャンバス/ノートブックビューの単位。1 シート = 1 グラフ（DAG）＋対応するセル列。

## 4. 機能要件（機能一覧）

### 4.1 キャンバス/編集
- ノードの配置/移動/複製/削除、ズーム/パン、スナップ/整列、Undo/Redo。
- シート管理：新規作成/名称変更/複製/削除、タブ切替、既定シートは 1 枚。
- ノードパレット（カテゴリ別）：
	- 基本：定数、変数、Python コード（自由記述）、コメント（Markdown）
	- I/O：CSV/Parquet/Excel 読込、ファイル書出し、HTTP GET/POST、DB 接続（拡張）
	- データ処理：Pandas（優先）/NumPy 演算、欠損処理、結合/集計
	- 可視化：matplotlib/plotly（最初は 1 つで可）、テーブルビュー
	- 制御：条件分岐（If/Switch）、マージ、サブグラフ/関数化、マップ（配列に関数適用）
- 接続：ポート同士をドラッグで接続/切断。型不一致は警告/禁止（設定で選択）。

### 4.2 ノード仕様
- 共通プロパティ：id、名前、タイプ、入力/出力ポート（型/説明）、パラメータ UI、コード/実装、位置、メタ情報（タグ/説明）。
- 型システム（ライトウェイト）：基本型（int/float/str/bool）、DataFrame、ndarray、Figure、任意（Any）。
- 型推論：入出力の実行時検査、想定と実測の乖離を UI に通知。
- サブグラフ：複数ノードを 1 ノードとして再利用できる（インライン展開/関数化）。
- カスタムノード：Python 関数から自動ノード化（シグネチャ/型ヒント/Docstring を取り込み）。

#### 4.2.1 MVP Pandas ノード（実装済の主な例）
- CSV 読込（ReadCSV）
	- 入力：なし（またはファイルパス/エンコーディング等のパラメータ）
	- 出力：DataFrame
	- 主パラメータ：path, sep, header, encoding, dtype, nrows, usecols
	- エラー：ファイル未存在、パース失敗、エンコーディング不一致
- 列選択（SelectColumns）
	- 入力：DataFrame
	- 出力：DataFrame
	- 主パラメータ：columns: string[]（補完/バリデーション）
- 行フィルタ（FilterRows）
	- 入力：DataFrame
	- 出力：DataFrame
	- 主パラメータ：query: string（pandas.DataFrame.query 構文、バリデーション/プレビュー）
	- エラー：構文エラー、存在しない列
- 列変換（Assign/Transform）
	- 入力：DataFrame
	- 出力：DataFrame
	- 主パラメータ：assign 式のマップ { new_col: expr }
	- 備考：安全のため式は `df.eval` 相当のサブセット（将来拡張）
- 結合（Join/Merge）
	- 入力：Left: DataFrame, Right: DataFrame
	- 出力：DataFrame
	- 主パラメータ：on/left_on/right_on、how（inner/left/right/outer/cross）、suffixes
- 集計（GroupByAggregate）
	- 入力：DataFrame
	- 出力：DataFrame
	- 主パラメータ：by: string|string[]、agg: { col: func|string|string[] }
	- エラー：キー列欠落、集計関数不正
- 可視化（Plot）
	- XYPlot, BarPlot, DistributionPlot, CorrHeatmap 等（matplotlibで画像出力）
	- 共通: figsize/dpi/タイトル/軸ラベル/グリッド等

共通 UI/検討事項：
- DataFrame のカラム候補/型推定をプレビューから取得し、パラメータ入力を支援。
- 大規模データは先頭/ランダムサンプル表示。集計・プロットはサンプリングオプション。
- 文字コードや区切り記号は記憶/推定（過去設定から提案）。

### 4.3 実行エンジン
- トポロジカル順序での実行、差分実行（Dirty Propagation）。
- キャッシュ：ノード出力のメモ化（入出力ハッシュ/パラメータ/コードの変化で無効化）。
- 実行モード：
	- 選択ノードのみ実行、下流のみ実行、全体実行。
	- ステップ実行/一時停止、タイムアウト設定、割り込み（Kernel Interrupt）。
- ストリーミング/イベント（拡張）：Source ノードが push、下流が逐次処理（v1.1 以降）。

### 4.4 Jupyter 連携（ライブ実行）
- カーネル管理：起動/停止/再起動、状態表示、同一フローに 1 カーネル（初期）。
- 変数同期：各ノード出力を命名規約に沿ってカーネル変数へ束縛、UI 変数インスペクタ。
- リアルタイム実行/出力更新：
	- Jupyter メッセージ（iopub: execute_result, display_data, stream, error, clear_output 等）を WebSocket で受信し、ノードごとのプレビューに即時反映。
	- 長大出力はサンプリング/省略表示（先頭/末尾 n 行、画像は縮小サムネイル）。
	- 再実行時の clear_output を尊重し、UI 側も表示を置き換え。
	- 実行の割り込み（interrupt）/キャンセル、キュー制御、タイムアウト。
- Notebook エクスポート：将来要件（v1.1 以降、任意）。現在はバックエンドのカーネルに直接コードを流す方式。
- 依存関係の記録：requirements.txt / environment.yml を生成/更新（オプション）。

### 4.5 パッケージ/環境
- Python 環境選択（システム/venv/conda）。
- パッケージ追加/削除 UI（pip/conda）。
- プロジェクトごとの requirements.txt 自動更新（実行中に import されたパッケージの検出は手動同意）。

### 4.6 永続化/バージョン管理
- プロジェクト保存：
	- flows/{name}.json（APIで保存/取得/削除）
	- env/requirements.txt（任意）
- 自動保存（間隔設定）、ローカル履歴、Git 連携（変更差分の可視化）。

### 4.7 表示/デバッグ
- ノードごとの実行ログ/トレースバック縮約表示、スタック展開。
- 出力プレビュー：
	- DataFrame：サンプル表示、ページング、列型、簡易統計。
	- 配列/画像/図：サムネイル、拡大ビュー。
- 実行時間、メモリ概算、キャッシュヒット率。

### 4.8 コラボレーション（拡張）
- マルチユーザー同時編集は将来要件（v1.2+）。
- 共有リンク（閲覧専用）、コメント、注釈（v1.1 以降）。

### 4.9 ノートブックビュー（線形化）
- 参考要件：キャンバス（グラフ）と並行して、ノードをトポロジカル順に線形化した「ノートブックビュー（セル一覧）」を提供（将来）。現状未実装。
- ノード≒セルの 1:1 対応。セルにはラベル、コード、出力、実行カウンタ（execution_count）を表示。
- 双方向同期：
	- ノードのコード編集＝セルのコード編集。どちらで変更しても即同期。
	- 実行は両ビューから可能（Run/Run from here/Run upstream/Run downstream）。
- 並び順：基本は DAG のトポロジカル順。ユーザーが明示順を設定した場合はその順を優先（ただし循環不可）。
- セクション/折りたたみ：サブグラフを 1 セクションとして折りたたみ可能。
- 「上から実行（Run All Above）」「以降を実行（Run All Below）」等の Notebook 的操作をサポート。
- シート切替：ノートブックビューも各シートごとに独立して表示・実行状態を保持。

## 5. 非機能要件

- パフォーマンス：
	- 目安：ノード数 ~100、同時可視化 ~10、DataFrame 数百万行はプレビューでサンプリング。
	- 初回カーネル起動 < 10 秒（環境に依存）。
	- ライブ更新の遅延：iopub 受信→UI 反映まで p50 < 150ms（ローカル想定）。
- 信頼性：
	- カーネルクラッシュからの復旧（自動再起動+再接続）。
	- 自動保存/復元、破損時のロールバック。
- 再現性：
	- 乱数シード設定サポート、環境固定（requirements.txt）。
- セキュリティ：
	- 任意コード実行のためローカル専用を初期前提。サンドボックス/権限分離は将来（v2.0）。
	- シークレットの取り扱い（.env/OS キーチェーン、マスク表示）。
- UX/アクセシビリティ：キーボード操作、ハイコントラスト、言語（日本語/英語）。
- ローカルファースト：ログイン不要・ローカル単体での利用を成立させる（ただしクラウド機能はサインインが必要）。
- 料金表示の明確性：無料範囲/有料範囲（例：2 枚目以降のシート）を UI 上で明示し、操作直前に説明する。
 - アカウント/企業識別（ホスト時）：アカウントID/企業IDによるポリシー適用（1 シート無料）を厳密化（将来 SSO 連携）。

## 6. アーキテクチャ概要（現況）

- フロントエンド：静的HTML + ESM JavaScript（独自UI）。
- バックエンド：
	- Jupyter Server（jupyter_server）と通信（WebSocket: iopub/実行結果、REST: セッション/カーネル）。
	- Graph API（CRUD、実行、キャッシュ）。実装は Python（FastAPI）または Node.js いずれか。Jupyter と親和性から Python 優先。
	- （ホスト運用/課金時）Run Gateway：実行の認可・メータリング・課金を仲介し、Jupyter への直接アクセスを遮蔽。
- 実行エンジン：
	- 各ノードを実行用Python断片に変換し、トポロジカル順にまとめて `/run` にPOST。
	- ノードごとにパラメータハッシュを保持し、未変更は実行スキップ（[[SKIP:...] の合図）。
	- 画像は `display(plt.gcf())` で返却し、WS経由でプレビュー反映。
- ストレージ：
	- プロジェクトルート直下に flows/{sheetId}/graph.json（複数シートに対応）、env/requirements.txt（任意）。

## 7. データモデル（草案）

```
Project {
	id, name, createdAt, updatedAt,
	settings { kernelEnv, caching, timeouts },
	sheets: Sheet[]
}

Sheet {
	id, name, createdAt, updatedAt,
	graph: Graph
}

Graph {
	id, version,
	nodes: Node[],
	edges: Edge[]
}

Node {
	id, type, label, position {x,y},
	inputs: Port[], outputs: Port[],
	params: { [key]: any },
	code?: string,  // Python ソース（コードノード/カスタム）
	meta?: { description, tags: string[] },
	runtime?: { state: 'idle'|'running'|'ok'|'error',
							startedAt?, endedAt?, error?, cacheKey?, samplePreview? }
}

Port { id, name, dtype: 'Any'|'int'|'float'|'str'|'bool'|'DataFrame'|'ndarray'|'Figure', optional?: boolean }

Edge { id, from: {nodeId, portId}, to: {nodeId, portId}, condition?: string }
```

補足：DataFrame のスキーマ扱い
- プレビューから列名・推定 dtype を取得してノードパラメータ UI に反映（遅延取得）。
- 型チェックは「参考」レベル（警告中心）。実行時に不一致検出でメッセージ表示。
- 将来：軽量スキーマ（列名/型）を Graph にオプション保存し、差分検知を高速化。

## 8. 実行/Kernel 連携の挙動

- 実行順序：DAG をトポロジカルソート。分岐/マージは制御ノードで実現。
- ノード→送信コード：各ノードを実行用 Python 断片に変換し、`execute_request` でカーネルへ送信。
- 変数束縛：スニペット末尾で `node_<id>_out0 = <expression>` 等により出力を束縛（複数出力は out1, out2...）。
- 出力取り扱い：iopub で受信した `execute_result`/`display_data`/`stream`/`error`/`clear_output` をノードのプレビュー/ログに反映。部分的なストリームも逐次更新。
- キャッシュ：実行前に cacheKey（コード+入力ハッシュ+パラメータ）を計算。一致時は実行スキップし、プレビューはキャッシュから復元（キャッシュ使用の旨を UI 表示）。
- エラー：例外/トレースバックを縮約表示し、クリックで展開。停止/継続ポリシーはユーザー選択。
- 実行カウンタ：Kernel の `execution_count` をノートブックビューの各セルにも反映し、実行履歴を可視化。
- 実行スコープ：セル単独実行時は上流未計算がある場合に自動で上流を先行実行（または警告して選択式）。

## 9. UI/UX 要件（要点）

- パレット検索（クイック検索）、ドラッグ＆ドロップ、ワイヤ接続のスナップ。
- ノードプロパティペイン（型、パラメータ、コードエディタ、説明）。
- 実行バー（Run/Stop/Step/Restart Kernel、キャッシュクリア）。
- プレビュータブ（表/図/ログ/型情報）。ストリームログは追従オプション（Auto-scroll）。
- ライブ更新：出力が到着次第差し替え/追記。長大出力は折りたたみ。図は滑らかに更新。
- 通知（完了、警告、エラー）。
- デュアルビュー：キャンバスとノートブックビューをスプリットで同時表示。相互ホバー/選択同期、エラー箇所の双方向ハイライト。

## 10. API（バックエンド）概要（現況）

REST（実装）
	- GET `/health`
	- POST `/run`, POST `/restart`
	- GET `/api/packages`
	- GET `/api/variables`, GET `/api/variables/{name}/export`
	- GET `/api/flows`, GET/POST/DELETE `/api/flows/{name}.json`
	- GET/POST/DELETE `/api/uploads` 系

WebSocket（実装）
	- `/ws`：iopubメッセージ（display_data/execute_result/stream/error/status）を中継
	- 課金関連イベント（ホスト運用時）：runAuthorized, runDenied, quotaLow, quotaExceeded, runRated（暫定課金結果）
	- 付随情報：各イベントに `execution_count`（可能な場合）や `nodeId`、`timestamp` を含め、ノートブックビュー同期に利用。

（課金/メータリング API：ホスト運用時）
- POST /runs/authorize：実行前見積り（料金/クレジット確認）+ 事前与信
- POST /runs/start：Run セッション開始（runId 発行、課金方針を確定）
- POST /runs/complete：使用量集計と確定課金（またはクレジット消費）
- GET /usage/summary, GET /usage/runs?from=&to=：利用状況取得
- Webhooks（例：/webhooks/stripe）：決済イベント受領


## 11. セキュリティ/権限（初期）

- ローカル環境前提（信頼済みコード）。
- 外部接続ノード（HTTP/DB）はユーザー明示操作が必要。
- シークレットは .env 参照（UI でマスク）。

## 12. 制約/前提/対象外

- 初期は単一ローカルカーネルのみ。リモートクラスタ/分散実行は対象外（将来）。
- フルサンドボックスは未対応（将来検討）。
- 極端に大規模なデータ（>メモリ）の分散処理は対象外（将来：Dask/Spark 連携）。

## 13. リスクと対策

- 任意コード実行の安全性：ローカル限定・警告明示。
- 依存関係ドリフト：requirements.txt 自動/半自動更新、環境エクスポート。
- Notebook 変換の乖離：生成ルールを明文化、往復変換の制限を明示。
- メモリ使用量：プレビューはサンプリング、キャッシュのサイズ上限/期限。
- 課金バイパス：Jupyter 直アクセスを禁止し、Run Gateway 経由の実行のみ許可（トークン非公開・ネットワーク分離）。
- 課金誤差/計測漏れ：メータリングは「確定報告（complete）」と「暫定インクリメント」の二段構え、冪等性キー採用。
- 返金/失敗時の整合性：実行失敗は全額返金（または従量の最小単位のみ請求）、監査ログを保持。

## 14. マイルストーン

- M0 プロトタイプ（4〜6 週間）：
	- ノード：Pandas 系（ReadCSV, SelectColumns, FilterRows, Assign, Join, GroupByAggregate, Plot）＋補助（Const, Python）
	- 実行（DAG/差分/キャッシュ簡易）、プレビュー、保存/ロード
	- 単一カーネル管理、リアルタイム出力反映（iopub 経由）
- M1（+6〜8 週間）：
	- 型チェック/警告、サブグラフ、エラーパネル強化
	- パッケージ管理、requirements.txt 生成
	- Notebook からの部分インポート（限定）
- M2（+8 週間）：
	- ストリーミング基本、HTTP/DB ノード、ダッシュボード化（簡易）
	- 共有（閲覧）、コメント

## 15. 受け入れ条件（初期）

- サンプルフローを作成→実行→プレビューが得られること。
- 再起動後もキャッシュを活用して差分実行されること。
- エラーがノード単位で可視化され、原因箇所が特定できること。
- カーネルからの出力（表/図/ログ）が遅延少なく UI にストリーミング反映されること。
（課金モード：ホスト運用時）
- 未課金/残高不足時に実行がブロックされ、明確な理由と購入導線が表示されること。
- 実行開始前に見積り/与信が行われ、完了時に使用量に応じた確定課金が行われること。
- 二重実行/再接続時も重複請求が発生しない（冪等性）こと。

## 17. 課金/メータリング（ホスト運用オプション）

目的：無料ローカル利用と、クラウド提供時のシンプルな料金（シート単位）＋上位の計算資源オプションを両立。

運用モード：
- ローカル（無料/MVP）：フロント→Jupyter 直結。課金なし、トークンはローカル限定。
- ホスト（有料）：フロント→Run Gateway→Jupyter。Gateway が認可・上限チェック・（必要に応じて）メータリング・課金・ストリーミング中継を担う。

課金モデル（基本方針）：
- 個人利用：無料（1 シート）
- 企業利用：1 企業あたり 1 シート無料。追加は有料（要お問い合わせ）。
- 追加オプション：計算資源（Compute）プロファイルのアップグレード課金（より高いCPU/メモリ/GPU）。

メータリング指標（上位オプション時）：
- runDurationSec、activeCpuTimeSec（取得可能なら）、bytesRead/bytesWritten（推定可）、rowsProcessed（プレビュー/ログから近似）。

フロー（標準）：
1) シート作成：サーバがアカウント/企業のシート数を確認。無料枠内なら許可、超過は支払い導線を案内。
2) 実行：通常は課金なし。Compute プロファイルが上位（有料）なら、実行前に権限チェックと課金確定（サブスクまたは定額）。
3) 変更：プラン/Compute のアップグレード/ダウングレード。次回請求または即時反映のポリシーを定義。

セキュリティ/強制力：
- Jupyter への直接到達を禁止（クラウド運用時／同一 VNet/内向きのみ）。フロントは Gateway のみと通信。
- Kernel は RunId/AccountId 単位のスコープで発行し、Gateway 以外のメッセージを拒否。

UX/エラー時：
- 無料枠超過：シート追加時に明確なモーダルで案内（無料 1 枚/現在 x 枚/上限 y 枚、価格）。
- 高性能 Compute 選択時：実行前の確認と価格表示、いつでもベーシックに戻せる導線。

監査/ログ：
- runId ごとに認可・開始・中間計測・完了・課金IDを紐づけて保存。署名/改ざん防止を検討。
- ノートブックビューでセルの実行/編集が可能で、キャンバスと内容・状態が即時同期されること（実行カウンタを含む）。

（Pandas 追加要件）
- 列選択/フィルタ/集計の UI に、プレビューから取得した列名候補が表示されること。
- CSV 読込でエンコーディング/区切りの誤り時に明確なエラーメッセージが表示されること。

## 16. 追補/今後の検討（現況差分）

- グラフ JSON スキーマの確定とサンプル定義。
- カスタムノードの配布/署名、マーケットプレイス構想。
- 遠隔カーネル（JupyterHub, VS Code Server, Colab/Deepnote 連携）検討。

---

## 18. 今後進めるべき内容（UX優先のタスク一覧）

短期（1–2週）
- 変数パネルの検索/フィルタ（名前・型・列名）と並べ替え
- DataFrameプレビューのページング/無限スクロール、列の固定/幅調整
- ノードのインラインヘルプ（ツールチップ、簡易チュートリアル）とサンプルフロー拡充
- 実行状態の明確化（ノードヘッダに進捗/時間、スキップ表示の視認性改善）
- エラー表示の改善（行番号/原因列の強調、再実行ガイド）

中期（3–6週）
- 入出力の型候補提示と軽量バリデーション（ユースケース阻害しない範囲）
- ファイル選択UIの改善（最近使ったファイル、アップロード履歴の並べ替え）
- フローのオートセーブとローカル履歴（巻き戻し）、ショートカットのヘルプパレット
- サブシステム（グループ）のテンプレ化と再利用、ドラッグコピーの操作改善
- 認証時のサインインUI改善（トークン期限・保存先の明示、WS再接続の自動復元）

将来（>6週）
- ノートブックビュー（線形化）の実装と双方向同期
- Notebookエクスポート/インポート（限定）
- マルチカーネル/リモート実行プロファイルのUI（Azure Gateway 前提の選択）
- マルチユーザー（閲覧共有→コメント→同時編集）
- 高度な可視化（対話的図、Plotly等）とダッシュボード化

注記
- ユーザ体験を最優先し、重い検証より「すぐ試せる・すぐ直せる」を重視。大きな変更はサンプルフローで検証しながら段階的に導入。


---

以上はドラフトです。次回は「必須/任意（MVP vs 後回し）」の優先度付けと、最初に実装するノードの確定（5〜7 種類）を一緒に行いたいです。
